
# Relax NG schema for OpenAL registry
# See https://github.com/NogginBops/OpenAL-EXT-Repository
#
# Last modified 2025/04/06
# This definition is subject to change (mostly in the form of additions)

namespace xsd = "http://www.w3.org/2001/XMLSchema-datatypes"

# Toplevel is a <registry> tag.
# May be led by an optional <comment> tag containing e.g. copyrights.
start = element registry {
    (
        element comment { text } ? |
        Types      * |
        Enums      * |
        Commands   * |
        Feature    * |
        Extensions *
    ) *
}

# <types> defines a group of types
Types = element types {
    Type *
}

# <type> defines a single type. It is usually a C typedef but
# may contain arbitrary C code.
#   name - name of this type, if not present in the <name> tag
#   api - matches a <feature> api attribute, if present
#   type - "group", if present, indicating a group of values in the
#       corresponding <enums> definition.
#   comment - unused
#   <apientry /> - substitutes for an APIENTRY-style macro on output
#   <name> - contains typename
Type = element type {
    attribute name { TypeName } ? ,
    attribute type { text } ? ,
    Comment ? ,
    text ,
    element name { TypeName } ? ,
    text
}

# <enums> defines a group of enumerants
#   namespace - identifies a numeric namespace
#   group - identifies a functional subset of the namespace - same as group=""
#   vendor - owner of the numeric range
#   type - "bitmask", if present
#   comment - unused
Enums = element enums {
    attribute namespace { text } ? ,
    attribute group { text } ? ,
    attribute type { text } ? ,
    Vendor ? ,
    Comment ? ,
    Enum *
}
# <enum> defines a single enumerant
#   value - integer (including hex) value of the enumerant
#   type - "u" (unsigned), "ull" (uint64), or integer if not present
#   name - enumerant name
#   group - identifies a functional subset of the namespace
#   alias - another enumerant this is semantically identical to
#   comment - unused
Enum = element enum {
    (
        attribute value { Integer } &
        attribute type { TypeSuffix } ? &
        attribute name { text } &
        attribute group { text } ? &
        attribute alias { text } ? &
        Comment ?
    )
}

# <commands> defines a group of commands
#   namespace - identifies a function namespace
Commands = element commands {
    attribute namespace { text } ? ,
    Command *
}
# <command> defines a single command
#   <proto> is the C function prototype, including the return type
#   <param> are function parameters, in order
#     class - type of object name (object handle). Handles with different types are not compatible. So handle created as [class=buffer] can not be passed to [class=shader]
#     <ptype> is a <type> name, if present
#     <name> is the function / parameter name
# The textual contents of <proto> and <param> should be legal C
# for those parts of a function declaration.
#   <alias> - denotes function aliasing
#     name - name of aliased function
#   <vecequiv> - denotes scalar / vector function equivalence
#     name - name of corresponding vector form, e.g. (alSourcef -> alSourcefv)
Command = element command {
    Comment ? ,
    element proto {
        attribute group { text } ? ,
        attribute class { text } ? ,
        text ,
        element ptype { TypeName } ? ,
        text ,
        element name { text } ,
        text
    } ,
    element param {
        attribute group { text } ? ,
        attribute class { text } ? ,
        attribute len { text } ? ,
        text ,
        element ptype { TypeName } ? ,
        text ,
        element name { text } ,
        text
    } * ,
    (
        element alias {
            Name
        } ? &
        element vecequiv {
            Name
        } ?
    )
}
# Each <feature> defines the interface of an API version (e.g. OpenAL 1.1)
#   api - API tag (e.g. 'al', 'alc', etc. - used internally, not
#     neccessarily an actual API name
#   name - version name (C preprocessor name, e.g. AL_VERSION_1_1)
#   number - version number, e.g. 1.1
#   protect - additional #ifdef symbol to place around the feature
#   <require> / <remove> contains features to require or remove in
#                        this version
#     profile - only require/remove when generated profile matches
#     comment - unused
Feature = element feature {
    attribute api { text } ,
    Name ,
    attribute number { xsd:float } ,
    attribute protect { text } ?,
    Comment ? ,
    (
        element require {
            Comment ? ,
            InterfaceElement *
        } |
        element remove {
            Comment ? ,
            InterfaceElement *
        }
    ) *
}
Extensions = element extensions {
    Extension *
}
# Defines the interface of an API <extension>. Like a <feature> tag.
Extension = element extension {
    Name ,
    attribute protect { text } ?,
    attribute supported { StringGroup } ? ,
    Comment ? ,
    (
        element require {
            Comment ? ,
            InterfaceElement *
        } |
        element remove {
            Comment ? ,
            InterfaceElement *
        }
    ) *
}
# Contents of a <require> / <remove> tag, defining a group
# of features to require or remove.
#   <type> / <enum> / <command> all have attributes
#     name - feature name which must match
InterfaceElement =
    element type {
        Name ,
        Comment ?
    } |
    element enum {
        Name ,
        Comment ?
    } |
    element command {
        Name ,
        Comment ?
    }

# Integers are allowed to be either decimal or C-hex (0x[0-9A-F]+), but
# XML Schema types don't seem to support hex notation, so we use this
# as a placeholder.
Integer = text

# TypeName is an argument/return value C type name
TypeName = text

# TypeSuffix is a C numeric type suffix, e.g. 'u' or 'ull'
TypeSuffix = text

# StringGroup is a regular expression with an implicit
#   '^(' and ')$' bracketing it.
StringGroup = text

# Repeatedly used attributes
Vendor = attribute vendor { text }
Comment = attribute comment { text }
Name = attribute name { text }
